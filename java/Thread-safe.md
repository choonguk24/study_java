## Java内存模型
### 线程安全性问题之可见性问题
#### Java内存模型 vs JVM运行时数据区
- Java虚拟机规范： 不同虚拟机达到一样的执行结果。（JVM运行时数据区）
- Java语言规范（JAVA内存模型）

多线程中的问题
1. 所见非所得
2. 无法肉眼去检测程序的准确性
3. 不同的运行平台有不同的表现
4. 错误很难重现

可见性问题
- 高速缓存（在极短的时间）
- CPU指令重排（保证单个 线程的一致性）： Java编程语言的语义允许Java编译器（JIT编译）和微处理器（CPU）进行优化，这些优化导致了与其交互的代码不在同步，从而导致看似矛盾的行为。

JIT编译器（Just In Time Compiler）

java源代码 -> 字节码 -> JVM（解释执行or JIT编译执行）
 - 当方法被频繁调用的时候升级成编译执行 

volatile关键字（禁止缓存和指令重排）
- 可见性问题： 让一个线程对共享变量的修改，能够及时的让气他线程看到。

Shared Variables定义
- 可以在线程之间共享的内存成为共享或堆内存。
- 所有实列字段，静态字段和数组元素都存储在堆内存中，这些字段和数组都是标题中提到的共享变量。
- 冲突： 如何至少有一个访问时写操作，那么对同一个变量的两次访问时冲突的。


线程间操作的定义
1. 一个程序执行的操作可被其它线程感知或被其它线程直接影响。
2. Java内存模型只描述线程间的操作， 不描述县城内操作， 线程内操作按照线程内语义执行。

对于同步的规则定义
- 对volatile变量v的写入，与所有其他线程后续对V的读同步。
- 对于监视器m的解锁与所有后续操作对于m的加锁同步
- 对于每个属性写入默认值（0，flase，null）：不会看到乱码
- 启动线程与线程的第一个操作同步（线程间感知其它线程状态）
- 线程最后一个操作
- 线程T2的最后操作与线程T1发现线程T2已经结束同步（isAlive,Join可以判断线程是否终结）
- 线程中断的状态同步（isInterrupted）

final在JVM中的处理
- final修饰可以看到final字段正确构造版本

 Word Tearing字节处理

 double和long的特殊处理
 - 对于非volatile的double，long的单词写操作是份两次来进行的（前32位，后32位，有可能导致脏读）


### 线程安全之原子性